### 5.2.1 Постановка задачи

#### Название проекта

Платформа для поиска практик и стажировок студентами вузов и колледжей (рабочее название: «SebStudy»).
#### Цель проекта и базы данных

Цель проекта заключается в создании удобной и специализированной платформы, которая связывает студентов вузов и колледжей, ищущих практику или стажировку, с компаниями, предлагающими такие возможности. Проект направлен на упрощение процесса поиска, подачи заявок и взаимодействия между студентами и работодателями, исключая лишние посреднические звенья.

База данных (БД) разрабатывается для обеспечения надежного хранения, управления и обработки данных, необходимых для функционирования платформы. Конечная цель — предоставить пользователям (студентам и компаниям) интуитивно понятный инструмент, который позволит:

- студентам находить подходящие вакансии практик/стажировок, подавать заявки и отслеживать их статус;
- компаниям размещать вакансии, просматривать резюме студентов и управлять процессом отбора.

На выходе ожидается полноценная веб-платформа с интегрированной базой данных, обеспечивающая автоматизацию процессов поиска, подачи заявок и взаимодействия между сторонами.

#### Для кого предназначен проект

Конечными пользователями платформы являются:

1. **Студенты вузов и колледжей** — основная целевая аудитория со стороны клиентов. Это молодые люди, которые ищут возможности для прохождения производственной практики или стажировки в рамках учебного процесса или для получения опыта работы.
2. **Компании** — представители бизнеса, которые нуждаются в практикантах или стажерах. Это могут быть как небольшие стартапы, так и крупные организации, готовые предоставить студентам временные рабочие места.
3. **Администраторы платформы** — сотрудники, обеспечивающие техническую поддержку, модерацию контента и управление системой (например, проверка корректности данных, разрешение споров).

##### Роли проекта и разграничение прав доступа к таблицам БД

1. **Студент**:
    - Доступ к таблицам: accounts, students, resumes, application_vacancies (чтение и запись только своих данных), vacancies (чтение).
    - Ограничения: студент может редактировать только свои данные (профиль, резюме) и подавать заявки на вакансии. Доступ к данным компаний ограничен просмотром вакансий.
2. **Компания**:
    - Доступ к таблицам: accounts, companies, vacancies (чтение и запись своих данных), application_vacancies (чтение и изменение статуса заявок), resumes (чтение резюме поданных заявок).
    - Ограничения: компания может управлять только своими вакансиями и данными, а также просматривать резюме студентов, подавших заявки.
3. **Администратор**:
    - Доступ к таблицам: полный доступ ко всем таблицам (accounts, students, companies, resumes, vacancies, application_vacancies, tg_accounts, educational_establishments, contracts) с правами чтения, записи, удаления и изменения.
    - Ограничения: отсутствуют, так как администратор отвечает за управление системой и устранение ошибок.

#### Функционал проекта и базы данных

Функционал платформы и базы данных разработан с учетом потребностей всех ролей.

##### Функции для роли "Студент":

1. **Регистрация и авторизация**: создание учетной записи через таблицу accounts с указанием статуса "студент" (is_company = 'false') и заполнение профиля в таблице students (имя, дата рождения, образование, контактные данные).
2. **Создание и редактирование резюме**: заполнение данных в таблице resumes (о себе, направление, проекты, портфолио, навыки).
3. **Поиск вакансий**: просмотр доступных вакансий из таблицы vacancies с фильтрацией по направлению, локации и требуемым навыкам.
4. **Подача заявки**: создание записи в таблице application_vacancies с привязкой к вакансии (vacancy_id) и резюме (resume_id), установка статуса "На рассмотрении".
5. **Отслеживание статуса заявок**: просмотр статуса заявок (status) в таблице application_vacancies.
6. **Интеграция с Telegram**: привязка учетной записи к Telegram через таблицу tg_accounts для получения уведомлений о статусе заявок.

##### Функции для роли "Компания":

1. **Регистрация и авторизация**: создание учетной записи через таблицу accounts с указанием статуса "компания" (is_company = 'true') и заполнение профиля в таблице companies (название, дата основания, описание, локация).
2. **Создание и управление вакансиями**: добавление вакансий в таблицу vacancies (описание практики, направление, проекты, требуемые навыки) и их редактирование.
3. **Просмотр заявок**: доступ к данным из таблицы application_vacancies для просмотра поданных резюме (resume_id) и изменения статуса заявки (например, "Принято", "Отклонено").
4. **Просмотр резюме**: чтение данных из таблицы resumes для оценки кандидатов.
5. **Заключение договоров**: добавление информации о договорах с образовательными учреждениями в таблицу contracts.

##### Функции для роли "Администратор":

1. **Модерация контента**: проверка и редактирование данных в таблицах vacancies, resumes, companies для предотвращения некорректной информации.
2. **Управление пользователями**: доступ к таблице accounts для блокировки или удаления учетных записей при нарушении правил.
3. **Работа с образовательными учреждениями**: добавление данных в таблицу educational_establishments и управление договорами в таблице contracts.
4. **Техническая поддержка**: решение проблем с доступом, восстановление данных, интеграция с Telegram через таблицу tg_accounts.

Таким образом, база данных обеспечивает выполнение всех ключевых функций платформы, поддерживая связь между студентами, компаниями и администрацией через четко структурированные таблицы и ограничения доступа.

### 5.2.2 Проектирование базы данных

База данных платформы "SebStudy" является реляционной и содержит 9 таблиц, что соответствует требованиям задания (не менее 7 таблиц). Проектирование начинается с формирования логической модели, которая затем подвергается нормализации для устранения аномалий и обеспечения целостности данных.

#### Основные объекты (сущности) базы данных с их атрибутами

На этапе логического проектирования выделены следующие основные сущности с их атрибутами:

1. **Аккаунт**:
    - Почта (email)
    - Пароль (password)
    - Является ли компанией (is_company)
2. **Студент**:
    - Имя (first_name)
    - Отчество (middle_name)
    - Фамилия (last_name)
    - Номер телефона (phone_number)
    - Образование (education)
    - Дата рождения (born_date)
    - Расположение (location)
    - Фото (photo)
3. **Компания**:
    - Название (title)
    - Фото (photo)
    - Дата основания (foundation_date)
    - О компании (about_company)
    - Расположение (location)
    - Контракты с учебными заведениями
4. **Резюме**:
    - О себе (about_me)
    - Направление (direction)
    - О проектах (about_projects)
    - Портфолио (portfolio)
    - Умения (skills)
5. **Вакансия**:
    - О практике (about_practice)
    - Направления (directions)
    - О проектах (about_projects)
    - Ожидаемые умения (expected_skills)
6. **Отклики**:
    - Статус (status)
    - Дата отклика (created_date)

#### Логические связи между объектами

Для обеспечения целостности данных определены следующие связи между сущностями:

- **Аккаунт** связан с **Студент** и **Компания**: один аккаунт может принадлежать либо студенту, либо компании (отношение "один-к-одному").
- **Студент** связан с **Резюме**: один студент может иметь одно или несколько резюме (отношение "один-ко-многим").
- **Компания** связана с **Вакансия**: одна компания может размещать несколько вакансий (отношение "один-ко-многим").
- **Резюме** и **Вакансия** связаны через **Отклики**: одно резюме может быть подано на несколько вакансий, а на одну вакансию могут откликнуться несколько резюме (отношение "многие-ко-многим").
- **Компания** связана с контрактами с учебными заведениями: одна компания может иметь несколько контрактов (отношение "один-ко-многим").

#### Логическая модель базы данных

![[Pasted image 20250409152144.png]]

`Рисунок 1 – Логическая модель базы данных "SebStudy" (Представьте схему с сущностями "Аккаунт", "Студент", "Компания", "Резюме", "Вакансия", "Отклики" и связями между ними, созданную в Obsidian с плагином Excalidraw.)`

#### Нормализация базы данных

После создания логической модели проводится нормализация для устранения аномалий вставки, обновления и удаления. Рассмотрим этапы нормализации:

##### Первая нормальная форма (1НФ)

Все атрибуты должны быть атомарными, повторяющиеся группы недопустимы.

- Проблема: в сущности "Компания" атрибут "контракты с учебными заведениями" может содержать список значений (например, несколько учебных заведений). Это нарушает 1НФ.
- Решение: выделяем контракты в отдельную сущность **"Контракты"** с атрибутами:
    - Дата заключения (сonclusion_date)
    - Идентификатор компании (company_id)
    - Идентификатор учебного заведения (ee_id).
- Также создаем сущность **"Учебные заведения"** с атрибутами:
    - Название (title)
    - Расположение (location).

##### Вторая нормальная форма (2НФ)

Все неключевые атрибуты должны зависеть от всего первичного ключа.

- Проблема: в сущности "Отклики" атрибуты status и created_date зависят от комбинации резюме и вакансии. Если использовать составной ключ (например, resume_id + vacancy_id), это соответствует 2НФ. Однако для удобства добавляем уникальный идентификатор id.
- Решение: таблица "Отклики" получает первичный ключ id, а resume_id и vacancy_id становятся внешними ключами.

##### Третья нормальная форма (3НФ)

Все атрибуты должны зависеть только от первичного ключа, а не от других неключевых атрибутов.

- Проблема: в сущности "Аккаунт" нет транзитивных зависимостей, но для расширения функционала (например, интеграции с Telegram) добавляется таблица **"Telegram-аккаунты"** с атрибутами:
    - Идентификатор Telegram (tg_id)
    - Идентификатор пользователя (user_id).
- Решение: выделяем эту сущность отдельно, связывая её с "Аккаунт" через внешний ключ user_id.

##### Итог нормализации

После устранения аномалий логическая модель превращается в нормализованную схему, которая представлена в предоставленном SQL-коде. Все таблицы имеют первичные ключи (обычно id типа UUID), а связи реализованы через внешние ключи с использованием FOREIGN KEY.

#### Индексы и ключи

- Первичные ключи (PRIMARY KEY) установлены для всех таблиц (например, id в каждой таблице).
- Внешние ключи (FOREIGN KEY) обеспечивают целостность связей:
    - companies.account_id → accounts.id
    - students.account_id → accounts.id
    - resumes.student_id → students.id
    - vacancies.company_id → companies.id
    - application_vacancies.resume_id → resumes.id
    - application_vacancies.vacancy_id → vacancies.id
    - contracts.company_id → companies.id
    - contracts.ee_id → educational_establishments.id
    - tg_accounts.user_id → accounts.id.

#### Конечная ER-модель базы данных

![[Pasted image 20250409152207.png]]

`Рисунок 2 – ER-модель базы данных "SebStudy" (Представьте схему с 9 таблицами и связями между ними, созданную в CASE-средстве.)`

#### Выбор CASE-средства

Для проектирования использовалось CASE-средство **drtawdb.app** (онлайн-инструмент).

- **Причина выбора**:
    - Простота интерфейса и возможность быстрого создания ER-диаграмм.
    - Поддержка экспорта SQL-кода, что упрощает проверку структуры.
    - Бесплатный доступ и работа в браузере, что удобно для командной работы.

Итоговая ER-модель полностью отражает нормализованную структуру базы данных, представленную в SQL-коде, и готова к реализации в реляционной СУБД PostgreSQL.

### 5.2.3 Составление технической документации на проект
Техническая документация на проект платформы "SebStudy" включает описание структуры базы данных, ссылочной целостности и ограничений на ввод данных. Эти элементы обеспечивают надежность, согласованность и корректность работы системы.

#### Ссылочная целостность и каскадные операции

Ссылочная целостность в базе данных поддерживается с помощью внешних ключей (FOREIGN KEY), которые связывают таблицы между собой. Для всех внешних ключей в проекте применяются каскадные операции ON DELETE CASCADE и ON UPDATE CASCADE. Это означает, что при удалении или обновлении записи в родительской таблице соответствующие изменения автоматически распространяются на дочерние таблицы. Рассмотрим каждую связь:

1. **Таблица tg_accounts → accounts**
    - Внешний ключ: user_id ссылается на accounts.id.
    - ON DELETE CASCADE: при удалении аккаунта из таблицы accounts соответствующие записи в tg_accounts (привязка к Telegram) также удаляются.
    - ON UPDATE CASCADE: при изменении id аккаунта в accounts значение user_id в tg_accounts автоматически обновляется.
2. **Таблица companies → accounts**
    - Внешний ключ: account_id ссылается на accounts.id.
    - ON DELETE CASCADE: удаление аккаунта компании из accounts приводит к удалению записи о компании из companies.
    - ON UPDATE CASCADE: изменение id аккаунта в accounts обновляет account_id в companies.
3. **Таблица students → accounts**
    - Внешний ключ: account_id ссылается на accounts.id.
    - ON DELETE CASCADE: удаление аккаунта студента из accounts удаляет запись о студенте из students.
    - ON UPDATE CASCADE: изменение id аккаунта в accounts обновляет account_id в students.
4. **Таблица resumes → students**
    - Внешний ключ: student_id ссылается на students.id.
    - ON DELETE CASCADE: удаление студента из students приводит к удалению всех его резюме из resumes.
    - ON UPDATE CASCADE: изменение id студента в students обновляет student_id в resumes.
5. **Таблица vacancies → companies**
    - Внешний ключ: company_id ссылается на companies.id.
    - ON DELETE CASCADE: удаление компании из companies удаляет все её вакансии из vacancies.
    - ON UPDATE CASCADE: изменение id компании в companies обновляет company_id в vacancies.
6. **Таблица application_vacancies → resumes**
    - Внешний ключ: resume_id ссылается на resumes.id.
    - ON DELETE CASCADE: удаление резюме из resumes удаляет все связанные с ним отклики из application_vacancies.
    - ON UPDATE CASCADE: изменение id резюме в resumes обновляет resume_id в application_vacancies.
7. **Таблица application_vacancies → vacancies**
    - Внешний ключ: vacancy_id ссылается на vacancies.id.
    - ON DELETE CASCADE: удаление вакансии из vacancies удаляет все связанные с ней отклики из application_vacancies.
    - ON UPDATE CASCADE: изменение id вакансии в vacancies обновляет vacancy_id в application_vacancies.
8. **Таблица contracts → companies**
    - Внешний ключ: company_id ссылается на companies.id.
    - ON DELETE CASCADE: удаление компании из companies удаляет все её контракты из contracts.
    - ON UPDATE CASCADE: изменение id компании в companies обновляет company_id в contracts.
9. **Таблица contracts → educational_establishments**
    - Внешний ключ: ee_id ссылается на educational_establishments.id.
    - ON DELETE CASCADE: удаление учебного заведения из educational_establishments удаляет все связанные с ним контракты из contracts.
    - ON UPDATE CASCADE: изменение id учебного заведения в educational_establishments обновляет ee_id в contracts.

Использование ON DELETE CASCADE и ON UPDATE CASCADE оправдано тем, что данные в дочерних таблицах теряют смысл без соответствующих записей в родительских таблицах. Например, резюме не может существовать без студента, а отклик — без резюме или вакансии. Это упрощает управление данными и предотвращает появление "осиротевших" записей.

#### Ограничения на ввод данных

Для обеспечения корректности и целостности данных в базе данных установлены следующие ограничения:

1. **Таблица accounts**:
    - id (UUID, NOT NULL, UNIQUE): уникальный идентификатор аккаунта, первичный ключ.
    - email (VARCHAR(255), NOT NULL): обязательное поле, должно содержать корректный адрес электронной почты (дополнительная проверка на уровне приложения).
    - password (VARCHAR(255), NOT NULL): обязательное поле, хранит хэш пароля.
    - is_company (VARCHAR(255), NOT NULL): обязательное поле, принимает значения "true" или "false" для определения типа аккаунта.
2. **Таблица companies**:
    - id (UUID, NOT NULL, UNIQUE): уникальный идентификатор компании, первичный ключ.
    - title (VARCHAR(255), NOT NULL): обязательное поле, название компании.
    - location (VARCHAR(255), NOT NULL): обязательное поле, местоположение компании.
    - account_id (UUID, NOT NULL): обязательное поле, ссылка на аккаунт компании.
3. **Таблица students**:
    - id (UUID, NOT NULL, UNIQUE): уникальный идентификатор студента, первичный ключ.
    - first_name (VARCHAR(255), NOT NULL): обязательное поле, имя студента.
    - born_date (DATE, NOT NULL): обязательное поле, дата рождения.
    - location (VARCHAR(255), NOT NULL): обязательное поле, местоположение студента.
    - account_id (UUID, NOT NULL): обязательное поле, ссылка на аккаунт студента.
4. **Таблица resumes**:
    - id (UUID, NOT NULL, UNIQUE): уникальный идентификатор резюме, первичный ключ.
    - about_me (VARCHAR(255), NOT NULL): обязательное поле, описание студента.
    - direction (VARCHAR(255), NOT NULL): обязательное поле, направление деятельности.
    - about_projects (VARCHAR(255), NOT NULL): обязательное поле, описание проектов.
    - portfolio (VARCHAR(255), NOT NULL): обязательное поле, ссылка на портфолио.
    - skills (VARCHAR(255), NOT NULL): обязательное поле, перечень навыков.
    - student_id (UUID, NOT NULL): обязательное поле, ссылка на студента.
5. **Таблица vacancies**:
    - id (UUID, NOT NULL, UNIQUE): уникальный идентификатор вакансии, первичный ключ.
    - about_practice (VARCHAR(255), NOT NULL): обязательное поле, описание практики.
    - directions (VARCHAR(255), NOT NULL): обязательное поле, направления вакансии.
    - about_projects (VARCHAR(255), NOT NULL): обязательное поле, описание проектов.
    - expected_skills (VARCHAR(255), NOT NULL): обязательное поле, требуемые навыки.
    - company_id (UUID, NOT NULL): обязательное поле, ссылка на компанию.
6. **Таблица application_vacancies**:
    - id (UUID, NOT NULL, UNIQUE): уникальный идентификатор отклика, первичный ключ.
    - status (VARCHAR(255), NOT NULL): обязательное поле, статус отклика (например, "На рассмотрении", "Принято").
    - created_date (TIMESTAMP, NOT NULL): обязательное поле, дата и время подачи отклика.
    - vacancy_id (UUID, NOT NULL): обязательное поле, ссылка на вакансию.
    - resume_id (UUID, NOT NULL): обязательное поле, ссылка на резюме.
7. **Таблица tg_accounts**:
    - tg_id (BIGINT, NOT NULL, UNIQUE): уникальный идентификатор Telegram, первичный ключ.
    - user_id (UUID, NOT NULL): обязательное поле, ссылка на аккаунт пользователя.
8. **Таблица educational_establishments**:
    - id (UUID, NOT NULL, UNIQUE): уникальный идентификатор учебного заведения, первичный ключ.
    - title (VARCHAR(255), NOT NULL): обязательное поле, название учебного заведения.
    - location (VARCHAR(255), NOT NULL): обязательное поле, местоположение.
9. **Таблица contracts**:
    - id (UUID, NOT NULL, UNIQUE): уникальный идентификатор контракта, первичный ключ.
    - сonclusion_date (DATE, NOT NULL): обязательное поле, дата заключения контракта.
    - company_id (UUID, NOT NULL): обязательное поле, ссылка на компанию.
    - ee_id (UUID, NOT NULL): обязательное поле, ссылка на учебное заведение.


### 5.2.4 Разработка базы данных

#### Выбор СУБД

Для реализации проекта платформы "SebStudy" в качестве системы управления базами данных (СУБД) была выбрана **PostgreSQL**. Этот выбор обоснован следующими причинами, связанными с особенностями проекта и задачами, которые необходимо решить:

1. **Поддержка реляционной модели данных**  
    PostgreSQL — это мощная реляционная СУБД, идеально подходящая для проекта "SebStudy", где требуется организовать сложную структуру базы данных с множеством таблиц и связей между ними (например, между студентами, компаниями, резюме и вакансиями).
2. **Расширенные типы данных**  
    PostgreSQL поддерживает такие типы данных, как UUID и JSON, что обеспечивает гибкость при работе с уникальными идентификаторами (используемыми в качестве первичных ключей) и структурированными данными (например, описаниями проектов или навыков).
3. **Высокая производительность и масштабируемость**  
    Платформа "SebStudy" рассчитана на большое количество пользователей — студентов и компаний. PostgreSQL демонстрирует отличную производительность при обработке больших объемов данных и поддерживает масштабирование, что делает её подходящей для растущего проекта.
4. **Безопасность данных**  
    PostgreSQL предлагает продвинутые механизмы управления доступом, шифрования и аудита. Это важно для защиты персональных данных студентов и конфиденциальной информации компаний, что является критическим требованием для платформы.
5. **Активное сообщество и документация**  
    У PostgreSQL большое сообщество разработчиков и подробная документация, что упрощает поиск решений проблем и интеграцию с другими инструментами, используемыми в разработке.
6. **Совместимость со стандартами**  
    Поддержка стандарта SQL обеспечивает совместимость PostgreSQL с популярными фреймворками и инструментами разработки веб-приложений, что упрощает интеграцию базы данных с платформой.
7. **Открытый исходный код и бесплатность**  
    PostgreSQL является открытым программным обеспечением, что исключает затраты на лицензирование и позволяет при необходимости адаптировать систему под специфические нужды проекта.

Таким образом, выбор PostgreSQL для "SebStudy" обусловлен её надежностью, гибкостью и соответствием требованиям проекта.

#### Код создания базы данных и таблиц

Ниже приведен SQL-код для создания базы данных studentpractice и всех необходимых таблиц. В коде учтены первичные ключи (PRIMARY KEY), уникальные ограничения (UNIQUE), внешние ключи (FOREIGN KEY) с каскадными операциями (ON DELETE CASCADE и ON UPDATE CASCADE), а также индексы, автоматически создаваемые для ключей.

```sql
CREATE TABLE "accounts" (
	"id" UUID NOT NULL UNIQUE,
	"email" VARCHAR(255) NOT NULL,
	"password" VARCHAR(255) NOT NULL,
	"is_company" VARCHAR(255) NOT NULL,
	PRIMARY KEY("id")
);

CREATE TABLE "companies" (
	"id" UUID NOT NULL UNIQUE,
	"title" VARCHAR(255) NOT NULL,
	"photo" VARCHAR(255),
	"foundation_date" TIME,
	"about_company" VARCHAR(255),
	"location" VARCHAR(255) NOT NULL,
	"account_id" UUID NOT NULL,
	PRIMARY KEY("id")
);

CREATE TABLE "students" (
	"id" UUID NOT NULL UNIQUE,
	"first_name" VARCHAR(255) NOT NULL,
	"last_name" VARCHAR(255),
	"middle_name" VARCHAR(255),
	"phone_number" VARCHAR(255),
	"education" VARCHAR(255),
	"born_date" DATE NOT NULL,
	"location" VARCHAR(255) NOT NULL,
	"photo" VARCHAR(255),
	"account_id" UUID NOT NULL,
	PRIMARY KEY("id")
);

CREATE TABLE "resumes" (
	"id" UUID NOT NULL UNIQUE,
	"about_me" VARCHAR(255) NOT NULL,
	"direction" VARCHAR(255) NOT NULL,
	"about_projects" VARCHAR(255) NOT NULL,
	"portfolio" VARCHAR(255) NOT NULL,
	"student_id" UUID NOT NULL,
	"skills" VARCHAR(255) NOT NULL,
	PRIMARY KEY("id")
);

CREATE TABLE "vacancies" (
	"id" UUID NOT NULL UNIQUE,
	"about_practice" VARCHAR(255) NOT NULL,
	"directions" VARCHAR(255) NOT NULL,
	"about_projects" VARCHAR(255) NOT NULL,
	"company_id" UUID NOT NULL,
	"expected_skills" VARCHAR(255) NOT NULL,
	PRIMARY KEY("id")
);

CREATE TABLE "application_vacancies" (
	"id" UUID NOT NULL UNIQUE,
	"status" VARCHAR(255) NOT NULL,
	"created_date" TIMESTAMP NOT NULL,
	"vacancy_id" UUID NOT NULL,
	"resume_id" UUID NOT NULL,
	PRIMARY KEY("id")
);

CREATE TABLE "tg_accounts" (
	"tg_id" BIGINT NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY,
	"user_id" UUID NOT NULL,
	PRIMARY KEY("tg_id")
);

CREATE TABLE "educational_establishments" (
	"id" UUID NOT NULL UNIQUE,
	"title" VARCHAR(255) NOT NULL,
	"location" VARCHAR(255) NOT NULL,
	PRIMARY KEY("id")
);

CREATE TABLE "contracts" (
	"id" UUID NOT NULL UNIQUE,
	"сonclusion_date" DATE NOT NULL,
	"company_id" UUID NOT NULL,
	"ee_id" UUID NOT NULL,
	PRIMARY KEY("id")
);

ALTER TABLE "tg_accounts"
ADD FOREIGN KEY("user_id") REFERENCES "accounts"("id")
ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE "companies"
ADD FOREIGN KEY("account_id") REFERENCES "accounts"("id")
ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE "contracts"
ADD FOREIGN KEY("company_id") REFERENCES "companies"("id")
ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE "contracts"
ADD FOREIGN KEY("ee_id") REFERENCES "educational_establishments"("id")
ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE "vacancies"
ADD FOREIGN KEY("company_id") REFERENCES "companies"("id")
ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE "resumes"
ADD FOREIGN KEY("student_id") REFERENCES "students"("id")
ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE "application_vacancies"
ADD FOREIGN KEY("resume_id") REFERENCES "resumes"("id")
ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE "application_vacancies"
ADD FOREIGN KEY("vacancy_id") REFERENCES "vacancies"("id")
ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE "students"
ADD FOREIGN KEY("account_id") REFERENCES "accounts"("id")
ON UPDATE CASCADE ON DELETE CASCADE;
```

#### Заполнение таблиц тестовыми данными

Для проверки работоспособности базы данных все таблицы были заполнены тестовыми данными. Данные импортируются из CSV-файлов с использованием команды \copy в PostgreSQL. Каждый CSV-файл содержит от 10 до 15 строк данных в зависимости от специфики таблицы. Пример команды импорта для таблицы accounts:

`-- Импорт данных в таблицу "accounts" \copy accounts(id, email, password, is_company) FROM 'path/to/accounts.csv' DELIMITER ',' CSV HEADER;`

Аналогичные команды применяются для остальных таблиц:

- \copy companies ... FROM 'path/to/companies.csv' DELIMITER ',' CSV HEADER;
- \copy students ... FROM 'path/to/students.csv' DELIMITER ',' CSV HEADER;
- \copy resumes ... FROM 'path/to/resumes.csv' DELIMITER ',' CSV HEADER;
- \copy vacancies ... FROM 'path/to/vacancies.csv' DELIMITER ',' CSV HEADER;
- \copy application_vacancies ... FROM 'path/to/application_vacancies.csv' DELIMITER ',' CSV HEADER;
- \copy tg_accounts ... FROM 'path/to/tg_accounts.csv' DELIMITER ',' CSV HEADER;
- \copy educational_establishments ... FROM 'path/to/educational_establishments.csv' DELIMITER ',' CSV HEADER;
- \copy contracts ... FROM 'path/to/contracts.csv' DELIMITER ',' CSV HEADER;

Где path/to/...csv — это путь к соответствующему CSV-файлу на вашем компьютере.

#### Скриншоты созданных таблиц и их содержимого
	
- **Рисунок 3** – Созданная таблица "accounts"
- **Рисунок 4** – Созданная таблица "companies"
- **Рисунок 5** – Содержание таблицы "accounts"
- **Рисунок 6** – Содержание таблицы "companies"
- (Далее аналогично для остальных таблиц: "students", "resumes", "vacancies", "application_vacancies", "tg_accounts", "educational_establishments", "contracts".)
#### Вывод

Разработка базы данных для платформы "SebStudy" выполнена с использованием PostgreSQL, что обеспечивает надежность, производительность и безопасность системы. Созданы все необходимые таблицы с учетом связей и ограничений, а тестовые данные импортированы для проверки функциональности.

```sql
-- Создание функции для триггера 
CREATE OR REPLACE FUNCTION update_account_status() 
RETURNS TRIGGER 
AS $$ 
BEGIN 
IF TG_TABLE_NAME = 'students' 
THEN 
UPDATE accounts SET is_company = 'false'
WHERE id = OLD.account_id AND NOT EXISTS (SELECT 1 FROM companies WHERE account_id = OLD.account_id); 
ELSIF TG_TABLE_NAME = 'companies' 
THEN 
UPDATE accounts SET is_company = 'true' WHERE id = OLD.account_id AND NOT EXISTS (SELECT 1 FROM students WHERE account_id = OLD.account_id); 
END IF; 
RETURN OLD; 
END; 
$$ LANGUAGE plpgsql;
-- Триггер для таблицы students 
CREATE TRIGGER trigger_update_account_after_student_delete AFTER DELETE ON students FOR EACH ROW EXECUTE FUNCTION update_account_status();
-- Триггер для таблицы companies
CREATE TRIGGER trigger_update_account_after_company_delete AFTER DELETE ON companies FOR EACH ROW EXECUTE FUNCTION update_account_status();

```

```sql
CREATE OR REPLACE PROCEDURE add_student_with_resume( p_account_id UUID, p_first_name VARCHAR(255), p_last_name VARCHAR(255), p_born_date DATE, p_location VARCHAR(255), p_about_me VARCHAR(255), p_direction VARCHAR(255), p_skills VARCHAR(255) )
LANGUAGE plpgsql 
AS $$ 
DECLARE v_student_id UUID := gen_random_uuid(); v_resume_id UUID := gen_random_uuid();
BEGIN 
-- Добавление студента 
INSERT INTO students (id, first_name, last_name, born_date, location, account_id) VALUES (v_student_id, p_first_name, p_last_name, p_born_date, p_location, p_account_id); 
-- Добавление резюме 
INSERT INTO resumes (id, about_me, direction, about_projects, portfolio, student_id, skills) VALUES (v_resume_id, p_about_me, p_direction, 'No projects yet', 'https://defaultportfolio.com', v_student_id, p_skills); RAISE NOTICE 'Student and resume added successfully!'; 
END; 
$$; 
-- Вызов процедуры 
CALL add_student_with_resume( '550e8400-e29b-41d4-a716-446655440010', 'Peter', 'Parker', '2001-08-15', 'New York', 'Aspiring web developer', 'Web Development', 'HTML, CSS, JavaScript' );
```

```sql
CREATE OR REPLACE PROCEDURE update_vacancy_applications( p_vacancy_id UUID, p_new_status VARCHAR(255) ) 
LANGUAGE plpgsql 
AS $$ 
BEGIN UPDATE application_vacancies SET status = p_new_status WHERE vacancy_id = p_vacancy_id; 
RAISE NOTICE 'Applications for vacancy % updated to %', p_vacancy_id, p_new_status; 
END; 
$$; 
-- Вызов процедуры 
CALL update_vacancy_applications('990e8400-e29b-41d4-a716-446655440000', 'Rejected');
```

### 5.2.5 Реализация запросов

Для базы данных "SebStudy" разработан набор SQL-запросов, соответствующих обязательным требованиям: добавление данных, удаление данных, изменение данных, а также 10 простых и 10 сложных запросов. Каждый запрос представлен с формулировкой, SQL-кодом и описанием результата. Скриншоты реализации запросов следует добавить в отчет самостоятельно.

---

#### Обязательные запросы

##### Добавление данных в таблицу

**Формулировка:** Добавить нового студента в таблицу students.

**SQL-код:**

`INSERT INTO students (id, first_name, last_name, middle_name, phone_number, education, born_date, location, photo, account_id) VALUES ('dd0e8400-e29b-41d4-a716-446655440000', 'Michael', 'Johnson', 'Lee', '+1234567890', 'Bachelor of Science', '2000-01-01', 'New York', 'https://example.com/photo16.jpg', '550e8400-e29b-41d4-a716-446655440000');`

**Описание результата:** В таблицу students добавляется запись о новом студенте с указанными данными: идентификатором, именем, фамилией, номером телефона, образованием, датой рождения, местоположением, ссылкой на фото и идентификатором аккаунта.

---

##### Удаление данных из таблицы

**Формулировка:** Удалить студента с идентификатором '770e8400-e29b-41d4-a716-446655440000' из таблицы students.

**SQL-код:**

`DELETE FROM students WHERE id = '770e8400-e29b-41d4-a716-446655440000';`

**Описание результата:** Из таблицы students удаляется запись о студенте с указанным id. Если настроено каскадное удаление (ON DELETE CASCADE), связанные записи в других таблицах (например, resumes) также будут удалены.

---

##### Изменение данных в таблице

**Формулировка:** Обновить телефонный номер студента с id = '770e8400-e29b-41d4-a716-446655440001' на '+0987654321'.

**SQL-код:**


`UPDATE students SET phone_number = '+0987654321' WHERE id = '770e8400-e29b-41d4-a716-446655440001';`

**Описание результата:** В таблице students для студента с указанным id обновляется поле phone_number на новый номер телефона.

---

#### 10 простых запросов

Простые запросы выполняются к одной таблице без сложных операций.

##### 1. Вывести всех студентов

**Формулировка:** Вывести имена и фамилии всех студентов.

**SQL-код:**

`SELECT first_name, last_name FROM students;`

**Описание результата:** Возвращается список всех студентов с их именами и фамилиями.

---

##### 2. Вывести компании из определенного города

**Формулировка:** Вывести названия компаний, расположенных в 'New York'.

**SQL-код:**

`SELECT title FROM companies WHERE location = 'New York';`

**Описание результата:** Возвращается список названий компаний, находящихся в 'New York'.

---

##### 3. Вывести резюме по направлению

**Формулировка:** Вывести все резюме с направлением 'Software Engineering'.

**SQL-код:**

`SELECT * FROM resumes WHERE direction = 'Software Engineering';`

**Описание результата:** Возвращаются все записи из таблицы resumes, где указано направление 'Software Engineering'.

---

##### 4. Вывести вакансии с определенными навыками

**Формулировка:** Вывести вакансии, требующие навыка 'Python'.

**SQL-код:**


`SELECT * FROM vacancies WHERE expected_skills LIKE '%Python%';`

**Описание результата:** Возвращаются вакансии, в которых среди ожидаемых навыков упоминается 'Python'.

---

##### 5. Вывести студентов старше определенного возраста

**Формулировка:** Вывести студентов, родившихся до '2000-01-01'.

**SQL-код:**


`SELECT first_name, last_name, born_date FROM students WHERE born_date < '2000-01-01';`

**Описание результата:** Возвращаются имена, фамилии и даты рождения студентов, родившихся до 1 января 2000 года.

---

##### 6. Вывести компании, основанные после определенной даты

**Формулировка:** Вывести компании, основанные после '2010-01-01'.

**SQL-код:**


`SELECT title, foundation_date FROM companies WHERE foundation_date > '2010-01-01';`

**Описание результата:** Возвращаются названия и даты основания компаний, созданных после 1 января 2010 года.

---

##### 7. Вывести резюме с портфолио

**Формулировка:** Вывести резюме, у которых есть портфолио.

**SQL-код:**


`SELECT * FROM resumes WHERE portfolio IS NOT NULL AND portfolio != '';`

**Описание результата:** Возвращаются резюме, у которых поле portfolio заполнено.

---

##### 8. Вывести образовательные учреждения по городу

**Формулировка:** Вывести образовательные учреждения, расположенные в 'San Francisco'.

**SQL-код:**


`SELECT title FROM educational_establishments WHERE location = 'San Francisco';`

**Описание результата:** Возвращаются названия образовательных учреждений, находящихся в 'San Francisco'.

---

##### 9. Вывести аккаунты компаний

**Формулировка:** Вывести email аккаунтов, которые принадлежат компаниям.

**SQL-код:**

`SELECT email FROM accounts WHERE is_company = 'true';`

**Описание результата:** Возвращаются email-адреса аккаунтов, помеченных как аккаунты компаний.

---

#### 10. Вывести заявки со статусом "Accepted"

**Формулировка:** Вывести все заявки со статусом 'Accepted'.

**SQL-код:**


`SELECT * FROM application_vacancies WHERE status = 'Accepted';`

**Описание результата:** Возвращаются все записи из таблицы application_vacancies со статусом 'Accepted'.

---

#### 10 сложных запросов

Сложные запросы затрагивают две и более таблицы и используют агрегатные функции, группировку или упорядочивание данных.

##### 1. Вывести количество резюме у каждого студента

**Формулировка:** Вывести имена студентов и количество их резюме.

**SQL-код:**


`SELECT s.first_name, s.last_name, COUNT(r.id) AS resume_count FROM students s LEFT JOIN resumes r ON s.id = r.student_id GROUP BY s.id, s.first_name, s.last_name;`

**Описание результата:** Возвращаются имена и фамилии студентов, а также количество созданных ими резюме.

---

##### 2. Вывести компании и количество их вакансий

**Формулировка:** Вывести названия компаний и количество размещенных ими вакансий.

**SQL-код:**


`SELECT c.title, COUNT(v.id) AS vacancy_count FROM companies c LEFT JOIN vacancies v ON c.id = v.company_id GROUP BY c.id, c.title;`

**Описание результата:** Возвращаются названия компаний и количество связанных с ними вакансий.

---

##### 3. Вывести студентов, подавших заявки на вакансии

**Формулировка:** Вывести имена студентов, которые подали заявки на вакансии, и названия компаний, на чьи вакансии они откликнулись.

**SQL-код:**


`SELECT s.first_name, s.last_name, c.title AS company_title FROM students s JOIN resumes r ON s.id = r.student_id JOIN application_vacancies av ON r.id = av.resume_id JOIN vacancies v ON av.vacancy_id = v.id JOIN companies c ON v.company_id = c.id;`

**Описание результата:** Возвращаются имена студентов и названия компаний, на вакансии которых поданы заявки.

---

##### 4. Вывести среднее количество заявок на вакансию

**Формулировка:** Вывести среднее количество заявок на каждую вакансию.

**SQL-код:**


`SELECT AVG(application_count) AS average_applications FROM ( SELECT v.id, COUNT(av.id) AS application_count FROM vacancies v LEFT JOIN application_vacancies av ON v.id = av.vacancy_id GROUP BY v.id ) AS subquery;`

**Описание результата:** Возвращается среднее число заявок на все вакансии.

---

##### 5. Вывести компании с наибольшим количеством контрактов

**Формулировка:** Вывести компании, у которых больше всего контрактов с образовательными учреждениями.

**SQL-код:**

`SELECT c.title, COUNT(con.id) AS contract_count FROM companies c JOIN contracts con ON c.id = con.company_id GROUP BY c.id, c.title ORDER BY contract_count DESC LIMIT 1;`

**Описание результата:** Возвращается название компании с наибольшим числом контрактов и это количество.

---

##### 6. Вывести студентов, не подавших ни одной заявки

**Формулировка:** Вывести имена студентов, которые не подавали заявки на вакансии.

**SQL-код:**

`SELECT s.first_name, s.last_name FROM students s LEFT JOIN resumes r ON s.id = r.student_id LEFT JOIN application_vacancies av ON r.id = av.resume_id WHERE av.id IS NULL;`

**Описание результата:** Возвращаются имена и фамилии студентов, у которых нет поданных заявок.

---

##### 7. Вывести вакансии с наибольшим количеством заявок

**Формулировка:** Вывести вакансии, на которые подано наибольшее количество заявок.

**SQL-код:**

`SELECT v.id, v.about_practice, COUNT(av.id) AS application_count FROM vacancies v JOIN application_vacancies av ON v.id = av.vacancy_id GROUP BY v.id, v.about_practice ORDER BY application_count DESC LIMIT 1;`

**Описание результата:** Возвращается вакансия с наибольшим числом заявок и это количество.

---

##### 8. Вывести студентов, чьи резюме содержат определенный навык

**Формулировка:** Вывести имена студентов, у которых в резюме указан навык 'Python'.

**SQL-код:**

`SELECT s.first_name, s.last_name FROM students s JOIN resumes r ON s.id = r.student_id WHERE r.skills LIKE '%Python%';`

**Описание результата:** Возвращаются имена и фамилии студентов, у которых в резюме есть навык 'Python'.

---

##### 9. Вывести компании, у которых есть контракты с определенным учреждением

**Формулировка:** Вывести компании, у которых есть контракты с 'University of Example'.

**SQL-код:**

`SELECT c.title FROM companies c JOIN contracts con ON c.id = con.company_id JOIN educational_establishments ee ON con.ee_id = ee.id WHERE ee.title = 'University of Example';`

**Описание результата:** Возвращаются названия компаний, имеющих контракты с 'University of Example'.

---

##### 10. Вывести количество заявок по статусам

**Формулировка:** Вывести количество заявок для каждого статуса.

**SQL-код:**

`SELECT status, COUNT(id) AS count FROM application_vacancies GROUP BY status ORDER BY count DESC;`

**Описание результата:** Возвращается количество заявок, сгруппированное по статусам, в порядке убывания.

### 5.2.6 Реализация триггеров и процедур

Для базы данных "SebStudy" разработаны триггеры и хранимые процедуры, которые обеспечивают автоматизацию процессов и контроль целостности данных. В данном разделе сформулированы задания, приведен SQL-код для их реализации в PostgreSQL, а также описаны результаты выполнения. Скриншоты с результатами вы добавите в отчет самостоятельно после выполнения кода.

---

#### Триггеры

##### Триггер 1: Автоматическое обновление статуса аккаунта при удалении студента или компании

**Задание:**  
Создать триггер, который при удалении записи из таблицы students или companies обновляет поле is_company в таблице accounts, устанавливая его в 'false' для студента или 'true' для компании, если соответствующий аккаунт больше не связан с другой сущностью.

**SQL-код:**

`-- Создание функции для триггера CREATE OR REPLACE FUNCTION update_account_status() RETURNS TRIGGER AS $$ BEGIN IF TG_TABLE_NAME = 'students' THEN UPDATE accounts SET is_company = 'false' WHERE id = OLD.account_id AND NOT EXISTS (SELECT 1 FROM companies WHERE account_id = OLD.account_id); ELSIF TG_TABLE_NAME = 'companies' THEN UPDATE accounts SET is_company = 'true' WHERE id = OLD.account_id AND NOT EXISTS (SELECT 1 FROM students WHERE account_id = OLD.account_id); END IF; RETURN OLD; END; $$ LANGUAGE plpgsql; -- Триггер для таблицы students CREATE TRIGGER trigger_update_account_after_student_delete AFTER DELETE ON students FOR EACH ROW EXECUTE FUNCTION update_account_status(); -- Триггер для таблицы companies CREATE TRIGGER trigger_update_account_after_company_delete AFTER DELETE ON companies FOR EACH ROW EXECUTE FUNCTION update_account_status();`

**Описание работы:**

- При удалении записи из таблицы students триггер проверяет, связан ли account_id с какой-либо компанией. Если нет, is_company в accounts устанавливается в 'false'.
- При удалении записи из таблицы companies триггер проверяет, связан ли account_id с каким-либо студентом. Если нет, is_company остается 'true'.
- Тест: удалите студента с id = '770e8400-e29b-41d4-a716-446655440000' и проверьте, обновилось ли поле is_company в таблице accounts.

**Результат:**  
После выполнения DELETE FROM students WHERE id = '770e8400-e29b-41d4-a716-446655440000'; в таблице accounts для записи с id = '550e8400-e29b-41d4-a716-446655440000' поле is_company станет 'false', если аккаунт не связан с компанией.

---

##### Триггер 2: Логирование добавления новых вакансий

**Задание:**  
Создать триггер, который при добавлении новой вакансии в таблицу vacancies записывает информацию об этом событии в таблицу логов vacancy_log.

**SQL-код:**

sql

СвернутьПереносКопировать

`-- Создание таблицы для логов CREATE TABLE vacancy_log ( log_id SERIAL PRIMARY KEY, vacancy_id UUID NOT NULL, company_id UUID NOT NULL, action VARCHAR(50) NOT NULL, action_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP ); -- Создание функции для триггера CREATE OR REPLACE FUNCTION log_vacancy_insert() RETURNS TRIGGER AS $$ BEGIN INSERT INTO vacancy_log (vacancy_id, company_id, action) VALUES (NEW.id, NEW.company_id, 'INSERT'); RETURN NEW; END; $$ LANGUAGE plpgsql; -- Триггер для таблицы vacancies CREATE TRIGGER trigger_log_vacancy_insert AFTER INSERT ON vacancies FOR EACH ROW EXECUTE FUNCTION log_vacancy_insert();`

**Описание работы:**

- При добавлении новой записи в таблицу vacancies триггер записывает id вакансии, company_id и действие 'INSERT' с текущей датой в таблицу vacancy_log.
- Тест: добавьте новую вакансию с помощью INSERT INTO vacancies ... и проверьте таблицу vacancy_log.

**Результат:**  
После выполнения:

`INSERT INTO vacancies (id, about_practice, directions, about_projects, company_id, expected_skills) VALUES ('990e8400-e29b-41d4-a716-446655440005', 'New internship', 'Web Development', 'Build a website', '660e8400-e29b-41d4-a716-446655440000', 'HTML, CSS');`

в таблице vacancy_log появится запись с соответствующими данными.

---

#### Процедуры

##### Процедура 1: Добавление студента с резюме

**Задание:**  
Создать процедуру, которая добавляет нового студента в таблицу students и сразу создает для него резюме в таблице resumes, используя переданные параметры.

**SQL-код:**

`CREATE OR REPLACE PROCEDURE add_student_with_resume( p_account_id UUID, p_first_name VARCHAR(255), p_last_name VARCHAR(255), p_born_date DATE, p_location VARCHAR(255), p_about_me VARCHAR(255), p_direction VARCHAR(255), p_skills VARCHAR(255) ) LANGUAGE plpgsql AS $$ DECLARE v_student_id UUID := gen_random_uuid(); v_resume_id UUID := gen_random_uuid(); BEGIN -- Добавление студента INSERT INTO students (id, first_name, last_name, born_date, location, account_id) VALUES (v_student_id, p_first_name, p_last_name, p_born_date, p_location, p_account_id); -- Добавление резюме INSERT INTO resumes (id, about_me, direction, about_projects, portfolio, student_id, skills) VALUES (v_resume_id, p_about_me, p_direction, 'No projects yet', 'https://defaultportfolio.com', v_student_id, p_skills); RAISE NOTICE 'Student and resume added successfully!'; END; $$; -- Вызов процедуры CALL add_student_with_resume( '550e8400-e29b-41d4-a716-446655440010', 'Peter', 'Parker', '2001-08-15', 'New York', 'Aspiring web developer', 'Web Development', 'HTML, CSS, JavaScript' );`

**Описание работы:**

- Процедура принимает параметры для студента и резюме, генерирует уникальные UUID для записей и последовательно добавляет их в таблицы students и resumes.
- Тест: вызовите процедуру с указанными параметрами и проверьте таблицы students и resumes.

**Результат:**  
После вызова процедуры в таблице students появится новый студент "Peter Parker", а в таблице resumes — его резюме с направлением "Web Development".

---

#### Процедура 2: Обновление статуса заявок по вакансии

**Задание:**  
Создать процедуру, которая обновляет статус всех заявок на указанную вакансию на заданное значение (например, 'Rejected').

**SQL-код:**


`CREATE OR REPLACE PROCEDURE update_vacancy_applications( p_vacancy_id UUID, p_new_status VARCHAR(255) ) LANGUAGE plpgsql AS $$ BEGIN UPDATE application_vacancies SET status = p_new_status WHERE vacancy_id = p_vacancy_id; RAISE NOTICE 'Applications for vacancy % updated to %', p_vacancy_id, p_new_status; END; $$; -- Вызов процедуры CALL update_vacancy_applications('990e8400-e29b-41d4-a716-446655440000', 'Rejected');`

**Описание работы:**

- Процедура принимает vacancy_id и новый статус, обновляет все записи в таблице application_vacancies, связанные с этой вакансией.
- Тест: вызовите процедуру для вакансии с id = '990e8400-e29b-41d4-a716-446655440000' и проверьте таблицу application_vacancies.

**Результат:**  
После вызова процедуры все заявки на вакансию с id = '990e8400-e29b-41d4-a716-446655440000' будут иметь статус 'Rejected'.


### 5.2.7 Реализация защиты объектов базы данных, разграничение прав пользователей базы данных

Для обеспечения безопасности данных в базе данных "SebStudy" необходимо создать пользователей (роли) и разграничить их права доступа. Это позволит ограничить действия пользователей в зависимости от их функций на платформе. Ниже описан процесс создания ролей и назначения им прав доступа с использованием SQL-команд в PostgreSQL.

---

#### Создание пользователей (ролей)

Для базы данных "SebStudy" выделим четыре основные роли пользователей на основе их функционала:

1. **Администратор (admin)** — полный доступ ко всем данным и операциям.
2. **Студент (student)** — доступ к своим данным и просмотр вакансий.
3. **Компания (company)** — доступ к своим данным и резюме поданных заявок.
4. **Модератор (moderator)** — права на модерацию контента (вакансий и резюме).

Роли создаются с помощью команды CREATE ROLE в PostgreSQL. Каждой роли задаются атрибуты, такие как возможность входа (LOGIN) и пароль.

**SQL-код для создания ролей:**

```sql
-- Создание роли администратора 
CREATE ROLE admin WITH LOGIN PASSWORD 'admin_password'; 
-- Создание роли студента 
CREATE ROLE student WITH LOGIN PASSWORD 'student_password'; 
-- Создание роли компании 
CREATE ROLE company WITH LOGIN PASSWORD 'company_password'; 
-- Создание роли модератора 
CREATE ROLE moderator WITH LOGIN PASSWORD 'moderator_password';
```

---

#### Разграничение прав доступа

После создания ролей каждой из них назначаются определенные права на таблицы базы данных с использованием команды GRANT. Права включают операции, такие как SELECT (чтение), INSERT (добавление), UPDATE (обновление) и DELETE (удаление).

##### 1. Права для роли **admin**

Администратор получает полный доступ ко всем таблицам и операциям.

**SQL-код:**

`-- Предоставление всех прав на все таблицы 
`GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO admin;`

##### 2. Права для роли **student**

Студент имеет доступ только к своим данным:

- Чтение и обновление профиля в таблице students.
- Работа со своими резюме в таблице resumes.
- Создание и просмотр заявок в таблице application_vacancies.
- Чтение вакансий в таблице vacancies.

**SQL-код:**

```sql
-- Права на чтение и обновление своих данных 
GRANT SELECT, UPDATE ON students TO student; 
GRANT SELECT, INSERT, UPDATE, DELETE ON resumes TO student; 
-- Права на чтение вакансий 
GRANT SELECT ON vacancies TO student;
GRANT SELECT, INSERT, UPDATE ON application_vacancies TO student;
```

##### 3. Права для роли **company**

Компания имеет доступ к своим данным:

- Чтение и обновление профиля в таблице companies.
- Работа со своими вакансиями в таблице vacancies.
- Чтение резюме и заявок в таблицах resumes и application_vacancies.

**SQL-код:**

```sql
-- Права на чтение и обновление своих данных 
GRANT SELECT, UPDATE ON companies TO company; 
GRANT SELECT, INSERT, UPDATE, DELETE ON vacancies TO company;
-- Права на чтение резюме поданных заявок 
GRANT SELECT ON resumes TO company; 
GRANT SELECT ON application_vacancies TO company;
```
##### 4. Права для роли **moderator**

Модератор отвечает за проверку контента:

- Чтение и обновление вакансий в таблице vacancies.
- Чтение и обновление резюме в таблице resumes.
- Чтение данных о студентах и компаниях в таблицах students и companies.

**SQL-код:**

```sql
-- Права на модерацию вакансий и резюме 
GRANT SELECT, UPDATE ON vacancies TO moderator; 
GRANT SELECT, UPDATE ON resumes TO moderator; 
-- Права на чтение данных о компаниях и студентах 
GRANT SELECT ON companies TO moderator; 
GRANT SELECT ON students TO moderator;
```

---

#### Ограничение доступа по умолчанию

Чтобы предотвратить несанкционированный доступ, необходимо отозвать все права у роли PUBLIC, которая по умолчанию имеет доступ к таблицам.

**SQL-код:**


`-- Отзыв всех прав PUBLIC`
`REVOKE ALL ON ALL TABLES IN SCHEMA public FROM PUBLIC;`

### 5.2.8 Реализация резервного копирования и восстановления базы данных

Для обеспечения надежности и сохранности данных в базе данных "SebStudy" необходимо реализовать процессы резервного копирования и восстановления. В данном разделе описан процесс создания резервной копии базы данных в PostgreSQL, а также ее восстановления. Эти операции выполняются с использованием утилит PostgreSQL pg_dump и pg_restore (или psql для восстановления из текстового дампа). Примеры команд приведены для работы в командной строке.

---

#### Резервное копирование базы данных

**Задача:**  
Создать резервную копию базы данных "SebStudy" для последующего восстановления в случае сбоя.

##### 1. Создание резервной копии в текстовом формате (SQL)

**Команда:**

`pg_dump -U username -d studentpractice > studentpractice_backup.sql`

- -U username: имя пользователя PostgreSQL (замените username на ваше имя пользователя, например, postgres).
- -d studentpractice: имя базы данных.
- > studentpractice_backup.sql: перенаправление вывода в файл studentpractice_backup.sql.

**Описание:**  
Утилита pg_dump извлекает структуру базы данных (таблицы, индексы, триггеры и т.д.) и данные в виде SQL-команд и сохраняет их в текстовый файл. Этот файл можно открыть и просмотреть, что полезно для анализа или ручного редактирования.

##### 2. Создание резервной копии в бинарном формате

**Команда:**

`pg_dump -U username -Fc -d studentpractice -f studentpractice_backup.dump`

- -Fc: использование пользовательского формата (бинарный, сжатый).
- -f studentpractice_backup.dump: сохранение в файл studentpractice_backup.dump.

**Описание:**  
Бинарный формат более компактный и быстрее восстанавливается, чем текстовый. Он используется с утилитой pg_restore.

**Примечание:**  
Для автоматизации резервного копирования можно настроить скрипт в cron (Linux) или планировщик задач (Windows). Пример cron-записи для ежедневного копирования в 2:00 AM:


`0 2 * * * pg_dump -U username -d studentpractice > /backups/studentpractice_backup_$(date +\%Y\%m\%d).sql`

---

#### Восстановление базы данных

**Задача:**  
Восстановить базу данных "SebStudy" из резервной копии после сбоя или для тестирования.

##### 1. Восстановление из текстового формата (SQL)

**Шаги:**

1. **Создать пустую базу данных (если она не существует):**


`createdb -U username studentpractice_restored`

2. **Восстановить данные из файла:**


`psql -U username -d studentpractice_restored < studentpractice_backup.sql`

- -d studentpractice_restored: имя базы данных, в которую выполняется восстановление.
- < studentpractice_backup.sql: чтение SQL-команд из файла.

**Описание:**  
Команда psql выполняет все SQL-команды из файла studentpractice_backup.sql, воссоздавая структуру и данные базы.

##### 2. Восстановление из бинарного формата

**Шаги:**

1. **Создать пустую базу данных (если нужно):**


`createdb -U username studentpractice_restored`

2. **Восстановить данные из файла:**


`pg_restore -U username -d studentpractice_restored --verbose studentpractice_backup.dump`

- --verbose: вывод подробной информации о процессе восстановления.
- studentpractice_backup.dump: файл резервной копии в бинарном формате.

**Описание:**  
Утилита pg_restore воссоздает базу данных из бинарного дампа. Этот метод быстрее и удобен для больших баз данных.

##### 3. Перезапись существующей базы данных (опционально)

Если нужно восстановить данные в уже существующую базу studentpractice, сначала удалите её и создайте заново:

`dropdb -U username studentpractice createdb -U username studentpractice psql -U username -d studentpractice < studentpractice_backup.sql`

Или для бинарного формата:


`dropdb -U username studentpractice createdb -U username studentpractice pg_restore -U username -d studentpractice studentpractice_backup.dump`

---

#### Тестирование резервного копирования и восстановления

1. **Создайте резервную копию:** Выполните команду pg_dump (например, для текстового формата):
    
    `pg_dump -U postgres -d studentpractice > studentpractice_backup.sql`
    
2. **Имитируйте сбой:** Удалите базу данных:
    
    `dropdb -U postgres studentpractice`
    
3. **Восстановите базу:** Создайте новую базу и восстановите данные:
    
    `createdb -U postgres studentpractice psql -U postgres -d studentpractice < studentpractice_backup.sql`
    
4. **Проверьте данные:** Подключитесь к базе через psql и выполните запрос, например:
    
    `SELECT * FROM students LIMIT 5;`
    
    Убедитесь, что данные восстановлены корректно.